using Ws2812LedController.Core.Utils;

namespace Ws2812LedController.Core.FastLedCompatibility;

public static class Beat
{
    private static readonly byte[] sine_wave = new byte[]{
        0x80, 0x83, 0x86, 0x89, 0x8C, 0x90, 0x93, 0x96,
        0x99, 0x9C, 0x9F, 0xA2, 0xA5, 0xA8, 0xAB, 0xAE,
        0xB1, 0xB3, 0xB6, 0xB9, 0xBC, 0xBF, 0xC1, 0xC4,
        0xC7, 0xC9, 0xCC, 0xCE, 0xD1, 0xD3, 0xD5, 0xD8,
        0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8,
        0xEA, 0xEB, 0xED, 0xEF, 0xF0, 0xF1, 0xF3, 0xF4,
        0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFA, 0xFB, 0xFC,
        0xFD, 0xFD, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFD,
        0xFD, 0xFC, 0xFB, 0xFA, 0xFA, 0xF9, 0xF8, 0xF6,
        0xF5, 0xF4, 0xF3, 0xF1, 0xF0, 0xEF, 0xED, 0xEB,
        0xEA, 0xE8, 0xE6, 0xE4, 0xE2, 0xE0, 0xDE, 0xDC,
        0xDA, 0xD8, 0xD5, 0xD3, 0xD1, 0xCE, 0xCC, 0xC9,
        0xC7, 0xC4, 0xC1, 0xBF, 0xBC, 0xB9, 0xB6, 0xB3,
        0xB1, 0xAE, 0xAB, 0xA8, 0xA5, 0xA2, 0x9F, 0x9C,
        0x99, 0x96, 0x93, 0x90, 0x8C, 0x89, 0x86, 0x83,
        0x80, 0x7D, 0x7A, 0x77, 0x74, 0x70, 0x6D, 0x6A,
        0x67, 0x64, 0x61, 0x5E, 0x5B, 0x58, 0x55, 0x52,
        0x4F, 0x4D, 0x4A, 0x47, 0x44, 0x41, 0x3F, 0x3C,
        0x39, 0x37, 0x34, 0x32, 0x2F, 0x2D, 0x2B, 0x28,
        0x26, 0x24, 0x22, 0x20, 0x1E, 0x1C, 0x1A, 0x18,
        0x16, 0x15, 0x13, 0x11, 0x10, 0x0F, 0x0D, 0x0C,
        0x0B, 0x0A, 0x08, 0x07, 0x06, 0x06, 0x05, 0x04,
        0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03,
        0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x0A,
        0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x13, 0x15,
        0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x24,
        0x26, 0x28, 0x2B, 0x2D, 0x2F, 0x32, 0x34, 0x37,
        0x39, 0x3C, 0x3F, 0x41, 0x44, 0x47, 0x4A, 0x4D,
        0x4F, 0x52, 0x55, 0x58, 0x5B, 0x5E, 0x61, 0x64,
        0x67, 0x6A, 0x6D, 0x70, 0x74, 0x77, 0x7A, 0x7D
    };
    
    public static byte beatsin8(ushort beats_per_minute, byte lowest = 0, byte highest = 255, uint timebase = 0, byte phase_offset = 0)
    {
        byte beat = beat8(beats_per_minute, timebase);
        byte beatsin = sine_wave[(byte)(beat + phase_offset)];
        byte rangewidth = (byte)(highest - lowest);
        byte scaledbeat = Scale.scale8(beatsin, rangewidth);
        byte result = (byte)(lowest + scaledbeat);
        return result;
    }
    
    public static ushort beatsin88(ushort beats_per_minute_88, ushort lowest = 0, ushort highest = 65535, uint timebase = 0, ushort phase_offset = 0)
    {
        ushort beat = beat88(beats_per_minute_88, timebase);
        ushort beatsin = (ushort)(Math8.Sin16((ushort)(beat + phase_offset)) + 32768);
        ushort rangewidth = (ushort)(highest - lowest);
        ushort scaledbeat = Scale.scale16(beatsin, rangewidth);
        ushort result = (ushort)(lowest + scaledbeat);
        return result;
    }

    /// beatsin16 generates a 16-bit sine wave at a given BPM,
    ///           that oscillates within a given range.
    public static ushort beatsin16(ushort beats_per_minute, ushort lowest = 0, ushort highest = 65535, uint timebase = 0, ushort phase_offset = 0)
    {
        ushort beat = beat16(beats_per_minute, timebase);
        ushort beatsin = (ushort)(Math8.Sin16((ushort)(beat + phase_offset)) + 32768);
        ushort rangewidth = (ushort)(highest - lowest);
        ushort scaledbeat = Scale.scale16(beatsin, rangewidth);
        ushort result = (ushort)(lowest + scaledbeat);
        return result;
    }

    
    /// beat8 generates an 8-bit 'sawtooth' wave at a given BPM
    public static byte beat8(ushort beats_per_minute, uint timebase = 0)
    {
        return (byte)(beat16(beats_per_minute, timebase) >> 8 );
    }
    
    public static ushort beat88( ushort beats_per_minute_88, uint timebase = 0)
    {
        // BPM is 'beats per minute', or 'beats per 60000ms'.
        // To avoid using the (slower) division operator, we
        // want to convert 'beats per 60000ms' to 'beats per 65536ms',
        // and then use a simple, fast bit-shift to divide by 65536.
        //
        // The ratio 65536:60000 is 279.620266667:256; we'll call it 280:256.
        // The conversion is accurate to about 0.05%, more or less,
        // e.g. if you ask for "120 BPM", you'll get about "119.93".
        return (ushort)(((Time.Millis() - timebase) * beats_per_minute_88 * 280) >> 16);
    }

    /// beat16 generates a 16-bit 'sawtooth' wave at a given BPM
    public static ushort beat16( ushort beats_per_minute, uint timebase = 0)
    {
        // Convert simple 8-bit BPM's to full Q8.8 accum88's if needed
        if( beats_per_minute < 256) beats_per_minute <<= 8;
        return beat88(beats_per_minute, timebase);
    }
}